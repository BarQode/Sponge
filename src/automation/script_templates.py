"""
Script Templates for Automation Generation

Provides templates for various automation scripts.
"""

from typing import Dict, Any
import textwrap


class ScriptTemplates:
    """Templates for automation scripts"""

    @staticmethod
    def bash_template(issue_type: str, commands: list) -> str:
        """
        Generate bash script template

        Args:
            issue_type: Type of issue being addressed
            commands: List of commands to execute

        Returns:
            Bash script as string
        """
        commands_str = '\n'.join([f'    {cmd}' for cmd in commands])

        script = f"""#!/bin/bash
# Automated fix for: {issue_type}
# Generated by Sponge RCA Tool

set -e  # Exit on error

echo "Starting automated fix for: {issue_type}"

# Main fix commands
{commands_str}

echo "Fix completed successfully"
"""
        return textwrap.dedent(script)

    @staticmethod
    def python_template(issue_type: str, fix_code: str) -> str:
        """
        Generate Python script template

        Args:
            issue_type: Type of issue being addressed
            fix_code: Python code for the fix

        Returns:
            Python script as string
        """
        script = f"""#!/usr/bin/env python3
\"\"\"
Automated fix for: {issue_type}
Generated by Sponge RCA Tool
\"\"\"

import logging
import sys
from datetime import datetime

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


def main():
    \"\"\"Execute automated fix\"\"\"
    logger.info("Starting automated fix for: {issue_type}")

    try:
{textwrap.indent(fix_code, '        ')}

        logger.info("Fix completed successfully")
        return 0

    except Exception as e:
        logger.error(f"Fix failed: {{e}}")
        return 1


if __name__ == "__main__":
    sys.exit(main())
"""
        return script

    @staticmethod
    def memory_leak_fix() -> Dict[str, str]:
        """Memory leak fix template"""
        return {
            'bash': """# Memory leak fix
ps aux --sort=-%mem | head -n 10
echo "Restarting high-memory processes..."
systemctl restart <service-name>
""",
            'python': """import psutil

# Find high-memory processes
for proc in psutil.process_iter(['pid', 'name', 'memory_percent']):
    if proc.info['memory_percent'] > 80:
        logger.info(f"High memory process: {proc.info['name']} ({proc.info['memory_percent']:.1f}%)")
        # Add restart logic here
"""
        }

    @staticmethod
    def high_cpu_fix() -> Dict[str, str]:
        """High CPU fix template"""
        return {
            'bash': """# High CPU fix
top -b -n 1 | head -n 20
echo "Identifying high-CPU processes..."
# Add process optimization commands
""",
            'python': """import psutil

# Find high-CPU processes
for proc in psutil.process_iter(['pid', 'name', 'cpu_percent']):
    if proc.info['cpu_percent'] > 80:
        logger.info(f"High CPU process: {proc.info['name']} ({proc.info['cpu_percent']:.1f}%)")
        # Add optimization logic here
"""
        }

    @staticmethod
    def zombie_process_fix() -> Dict[str, str]:
        """Zombie process fix template"""
        return {
            'bash': """# Zombie process cleanup
ps aux | grep 'Z'
echo "Cleaning up zombie processes..."
# Kill parent processes of zombies
kill -9 $(ps -A -ostat,ppid | awk '/[zZ]/{print $2}')
""",
            'python': """import psutil
import os
import signal

# Find and clean zombie processes
for proc in psutil.process_iter(['pid', 'status', 'ppid']):
    if proc.info['status'] == psutil.STATUS_ZOMBIE:
        logger.info(f"Found zombie process: {proc.info['pid']}")
        try:
            parent = psutil.Process(proc.info['ppid'])
            parent.send_signal(signal.SIGCHLD)
        except psutil.NoSuchProcess:
            logger.warning(f"Parent process not found")
"""
        }

    @staticmethod
    def disk_cleanup_fix() -> Dict[str, str]:
        """Disk cleanup fix template"""
        return {
            'bash': """# Disk cleanup
df -h
echo "Cleaning up disk space..."
# Clean tmp files
find /tmp -type f -atime +7 -delete
# Clean logs
find /var/log -name "*.log" -type f -size +100M -exec truncate -s 0 {} \\;
# Clean package manager cache
apt-get clean || yum clean all
""",
            'python': """import os
import shutil
from pathlib import Path

# Clean temporary files
tmp_dir = Path('/tmp')
for file in tmp_dir.glob('*'):
    if file.stat().st_mtime < (datetime.now().timestamp() - 7*24*3600):
        try:
            if file.is_file():
                file.unlink()
            elif file.is_dir():
                shutil.rmtree(file)
            logger.info(f"Cleaned: {file}")
        except Exception as e:
            logger.warning(f"Failed to clean {file}: {e}")
"""
        }

    @staticmethod
    def service_restart_fix(service_name: str) -> Dict[str, str]:
        """Service restart fix template"""
        return {
            'bash': f"""# Restart service: {service_name}
echo "Checking service status..."
systemctl status {service_name}

echo "Restarting service..."
systemctl restart {service_name}

echo "Verifying service is running..."
systemctl is-active {service_name}
""",
            'python': f"""import subprocess

service_name = "{service_name}"

# Check service status
logger.info(f"Checking {{service_name}} status...")
result = subprocess.run(['systemctl', 'status', service_name], capture_output=True)

# Restart service
logger.info(f"Restarting {{service_name}}...")
subprocess.run(['systemctl', 'restart', service_name], check=True)

# Verify service is running
result = subprocess.run(['systemctl', 'is-active', service_name], capture_output=True)
if result.returncode == 0:
    logger.info(f"{{service_name}} is now active")
else:
    raise Exception(f"{{service_name}} failed to start")
"""
        }

    @staticmethod
    def log_rotation_fix() -> Dict[str, str]:
        """Log rotation fix template"""
        return {
            'bash': """# Log rotation
echo "Setting up log rotation..."

cat > /etc/logrotate.d/app << EOF
/var/log/app/*.log {
    daily
    rotate 7
    compress
    delaycompress
    missingok
    notifempty
    create 644 root root
}
EOF

logrotate -f /etc/logrotate.d/app
""",
            'python': """import subprocess
from pathlib import Path

# Create logrotate config
config = \"\"\"
/var/log/app/*.log {
    daily
    rotate 7
    compress
    delaycompress
    missingok
    notifempty
    create 644 root root
}
\"\"\"

config_path = Path('/etc/logrotate.d/app')
config_path.write_text(config)

# Force rotation
subprocess.run(['logrotate', '-f', str(config_path)], check=True)
logger.info("Log rotation configured")
"""
        }

    @staticmethod
    def database_optimization_fix() -> Dict[str, str]:
        """Database optimization fix template"""
        return {
            'bash': """# Database optimization
echo "Optimizing database..."

# PostgreSQL
psql -U postgres -c "VACUUM ANALYZE;"
psql -U postgres -c "REINDEX DATABASE your_database;"

# MySQL
mysql -u root -p -e "OPTIMIZE TABLE your_table;"
""",
            'python': """import psycopg2

# PostgreSQL optimization
try:
    conn = psycopg2.connect("dbname=your_db user=postgres")
    conn.set_isolation_level(0)  # autocommit
    cur = conn.cursor()

    logger.info("Running VACUUM ANALYZE...")
    cur.execute("VACUUM ANALYZE;")

    logger.info("Running REINDEX...")
    cur.execute("REINDEX DATABASE your_database;")

    cur.close()
    conn.close()
    logger.info("Database optimization complete")

except Exception as e:
    logger.error(f"Database optimization failed: {e}")
    raise
"""
        }

    @staticmethod
    def network_troubleshooting_fix() -> Dict[str, str]:
        """Network troubleshooting fix template"""
        return {
            'bash': """# Network troubleshooting
echo "Checking network connectivity..."
ping -c 4 8.8.8.8

echo "Checking DNS resolution..."
nslookup google.com

echo "Checking listening ports..."
netstat -tuln

echo "Restarting network service..."
systemctl restart NetworkManager
""",
            'python': """import subprocess
import socket

# Check connectivity
logger.info("Checking network connectivity...")
result = subprocess.run(['ping', '-c', '4', '8.8.8.8'], capture_output=True)
if result.returncode != 0:
    logger.error("Network connectivity issues detected")

# Check DNS
logger.info("Checking DNS resolution...")
try:
    socket.gethostbyname('google.com')
    logger.info("DNS resolution working")
except socket.gaierror:
    logger.error("DNS resolution failed")

# Restart network service
logger.info("Restarting network service...")
subprocess.run(['systemctl', 'restart', 'NetworkManager'], check=True)
"""
        }

    @staticmethod
    def get_template(issue_type: str, language: str = 'bash') -> str:
        """
        Get template for specific issue type

        Args:
            issue_type: Type of issue
            language: Script language (bash or python)

        Returns:
            Template string
        """
        templates = {
            'memory_leak': ScriptTemplates.memory_leak_fix(),
            'high_cpu': ScriptTemplates.high_cpu_fix(),
            'zombie_process': ScriptTemplates.zombie_process_fix(),
            'disk_space': ScriptTemplates.disk_cleanup_fix(),
            'log_rotation': ScriptTemplates.log_rotation_fix(),
            'database_slow': ScriptTemplates.database_optimization_fix(),
            'network_issue': ScriptTemplates.network_troubleshooting_fix()
        }

        if issue_type in templates:
            return templates[issue_type].get(language, '')

        return ""
