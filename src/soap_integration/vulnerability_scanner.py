"""
Vulnerability Scanner

Scans SaaS applications for security vulnerabilities.
"""

import re
import json
import subprocess
import logging
from datetime import datetime
from typing import Dict, Any, List
from pathlib import Path
import requests

logger = logging.getLogger(__name__)


class VulnerabilityScanner:
    """Scans for vulnerabilities in running SaaS applications"""

    def __init__(self):
        """Initialize vulnerability scanner"""
        self.scan_results = []
        self.cve_database = self._load_cve_database()

    def scan_environment(self, environment: str) -> List[Dict[str, Any]]:
        """
        Scan environment for vulnerabilities

        Args:
            environment: Environment to scan

        Returns:
            List of detected vulnerabilities
        """
        logger.info(f"Starting vulnerability scan for {environment}")

        vulnerabilities = []

        # 1. Scan container images
        vulnerabilities.extend(self._scan_container_images(environment))

        # 2. Scan dependencies
        vulnerabilities.extend(self._scan_dependencies())

        # 3. Scan for exposed secrets
        vulnerabilities.extend(self._scan_secrets())

        # 4. Scan SSL/TLS certificates
        vulnerabilities.extend(self._scan_certificates())

        # 5. Scan for CVEs
        vulnerabilities.extend(self._scan_known_cves())

        # 6. Scan configurations
        vulnerabilities.extend(self._scan_configurations())

        logger.info(f"Scan complete: {len(vulnerabilities)} vulnerabilities found")

        return vulnerabilities

    def _scan_container_images(self, environment: str) -> List[Dict[str, Any]]:
        """Scan container images for vulnerabilities"""
        logger.info("Scanning container images")

        vulnerabilities = []

        try:
            # Use Trivy for container scanning
            result = subprocess.run(
                ['trivy', 'image', '--format', 'json', '--severity', 'HIGH,CRITICAL', 'sponge:latest'],
                capture_output=True,
                text=True,
                timeout=300
            )

            if result.returncode == 0:
                scan_data = json.loads(result.stdout)

                for vuln in scan_data.get('Results', []):
                    for v in vuln.get('Vulnerabilities', []):
                        vulnerabilities.append({
                            'id': f"IMG-{v.get('VulnerabilityID', 'unknown')}",
                            'severity': v.get('Severity', 'UNKNOWN').lower(),
                            'cve_id': v.get('VulnerabilityID', ''),
                            'description': v.get('Description', ''),
                            'component': v.get('PkgName', ''),
                            'fix_available': v.get('FixedVersion', '') != '',
                            'remediation': self._get_image_remediation(v)
                        })

        except FileNotFoundError:
            logger.warning("Trivy not installed, skipping image scan")
        except Exception as e:
            logger.error(f"Image scan error: {e}")

        return vulnerabilities

    def _scan_dependencies(self) -> List[Dict[str, Any]]:
        """Scan Python dependencies for vulnerabilities"""
        logger.info("Scanning dependencies")

        vulnerabilities = []

        try:
            # Use safety or pip-audit
            result = subprocess.run(
                ['safety', 'check', '--json'],
                capture_output=True,
                text=True,
                timeout=60
            )

            if result.stdout:
                scan_data = json.loads(result.stdout)

                for vuln in scan_data:
                    vulnerabilities.append({
                        'id': f"DEP-{vuln[0]}",
                        'severity': self._classify_severity(vuln),
                        'cve_id': vuln[4] if len(vuln) > 4 else '',
                        'description': vuln[3],
                        'component': vuln[1],
                        'fix_available': True,
                        'remediation': [
                            f"Update {vuln[1]} to version {vuln[2]}",
                            "Run: pip install --upgrade {vuln[1]}"
                        ]
                    })

        except FileNotFoundError:
            logger.warning("Safety not installed, skipping dependency scan")
        except Exception as e:
            logger.error(f"Dependency scan error: {e}")

        return vulnerabilities

    def _scan_secrets(self) -> List[Dict[str, Any]]:
        """Scan for exposed secrets"""
        logger.info("Scanning for exposed secrets")

        vulnerabilities = []

        # Common secret patterns
        patterns = {
            'aws_key': r'AKIA[0-9A-Z]{16}',
            'private_key': r'-----BEGIN (RSA |EC )?PRIVATE KEY-----',
            'api_key': r'api[_-]?key["\']?\s*[:=]\s*["\']?([a-zA-Z0-9]{32,})',
            'password': r'password["\']?\s*[:=]\s*["\']([^"\']+)["\']',
            'token': r'token["\']?\s*[:=]\s*["\']([a-zA-Z0-9]{20,})'
        }

        try:
            # Scan common files
            files_to_scan = [
                '.env',
                'config.yaml',
                'config.json',
                'docker-compose.yml'
            ]

            for filename in files_to_scan:
                file_path = Path(filename)
                if file_path.exists():
                    content = file_path.read_text()

                    for secret_type, pattern in patterns.items():
                        matches = re.findall(pattern, content, re.IGNORECASE)
                        if matches:
                            vulnerabilities.append({
                                'id': f"SECRET-{secret_type}-{datetime.now().strftime('%Y%m%d%H%M%S')}",
                                'severity': 'critical',
                                'cve_id': '',
                                'description': f"Exposed {secret_type} found in {filename}",
                                'component': filename,
                                'fix_available': True,
                                'remediation': [
                                    f"Remove {secret_type} from {filename}",
                                    "Use environment variables or secret management",
                                    "Rotate the exposed secret immediately"
                                ]
                            })

        except Exception as e:
            logger.error(f"Secret scan error: {e}")

        return vulnerabilities

    def _scan_certificates(self) -> List[Dict[str, Any]]:
        """Scan SSL/TLS certificates"""
        logger.info("Scanning certificates")

        vulnerabilities = []

        try:
            # Check certificate expiration
            import ssl
            import socket
            from datetime import datetime, timedelta

            domains = self._get_monitored_domains()

            for domain in domains:
                try:
                    context = ssl.create_default_context()
                    with socket.create_connection((domain, 443), timeout=5) as sock:
                        with context.wrap_socket(sock, server_hostname=domain) as ssock:
                            cert = ssock.getpeercert()

                            # Check expiration
                            not_after = datetime.strptime(cert['notAfter'], '%b %d %H:%M:%S %Y %Z')
                            days_until_expiry = (not_after - datetime.now()).days

                            if days_until_expiry < 30:
                                severity = 'critical' if days_until_expiry < 7 else 'high'
                                vulnerabilities.append({
                                    'id': f"CERT-{domain}",
                                    'severity': severity,
                                    'cve_id': '',
                                    'description': f"Certificate for {domain} expires in {days_until_expiry} days",
                                    'component': domain,
                                    'fix_available': True,
                                    'remediation': [
                                        f"Renew certificate for {domain}",
                                        "Use automated certificate management (Let's Encrypt)"
                                    ]
                                })

                except Exception as e:
                    logger.warning(f"Certificate check failed for {domain}: {e}")

        except Exception as e:
            logger.error(f"Certificate scan error: {e}")

        return vulnerabilities

    def _scan_known_cves(self) -> List[Dict[str, Any]]:
        """Scan for known CVEs"""
        logger.info("Scanning for known CVEs")

        vulnerabilities = []

        try:
            # Get installed packages
            result = subprocess.run(
                ['pip', 'list', '--format=json'],
                capture_output=True,
                text=True
            )

            if result.returncode == 0:
                packages = json.loads(result.stdout)

                for pkg in packages:
                    pkg_name = pkg['name']
                    pkg_version = pkg['version']

                    # Check against CVE database
                    if pkg_name in self.cve_database:
                        for cve in self.cve_database[pkg_name]:
                            if self._version_affected(pkg_version, cve['affected_versions']):
                                vulnerabilities.append({
                                    'id': cve['cve_id'],
                                    'severity': cve['severity'],
                                    'cve_id': cve['cve_id'],
                                    'description': cve['description'],
                                    'component': f"{pkg_name} {pkg_version}",
                                    'fix_available': True,
                                    'remediation': cve['remediation']
                                })

        except Exception as e:
            logger.error(f"CVE scan error: {e}")

        return vulnerabilities

    def _scan_configurations(self) -> List[Dict[str, Any]]:
        """Scan for insecure configurations"""
        logger.info("Scanning configurations")

        vulnerabilities = []

        # Check Docker daemon configuration
        try:
            result = subprocess.run(
                ['docker', 'info', '--format', '{{json .}}'],
                capture_output=True,
                text=True
            )

            if result.returncode == 0:
                docker_info = json.loads(result.stdout)

                # Check for security issues
                if not docker_info.get('SecurityOptions'):
                    vulnerabilities.append({
                        'id': 'CONFIG-DOCKER-001',
                        'severity': 'medium',
                        'cve_id': '',
                        'description': 'Docker security options not configured',
                        'component': 'Docker',
                        'fix_available': True,
                        'remediation': [
                            'Enable AppArmor or SELinux',
                            'Configure user namespaces',
                            'Enable content trust'
                        ]
                    })

        except Exception as e:
            logger.warning(f"Docker config scan failed: {e}")

        return vulnerabilities

    def _load_cve_database(self) -> Dict[str, List[Dict]]:
        """Load CVE database (simplified)"""
        # In production, load from NVD or similar
        return {
            'tensorflow': [
                {
                    'cve_id': 'CVE-2023-EXAMPLE',
                    'severity': 'high',
                    'description': 'Example CVE',
                    'affected_versions': ['<2.15.0'],
                    'remediation': ['Upgrade to TensorFlow 2.15.0+']
                }
            ]
        }

    def _get_monitored_domains(self) -> List[str]:
        """Get list of domains to monitor"""
        # In production, load from configuration
        return []

    def _version_affected(self, version: str, affected: str) -> bool:
        """Check if version is affected by CVE"""
        # Simplified version comparison
        return True  # Implement proper version comparison

    def _classify_severity(self, vuln_data: Any) -> str:
        """Classify vulnerability severity"""
        # Implement severity classification logic
        return 'high'

    def _get_image_remediation(self, vuln: Dict) -> List[str]:
        """Get remediation steps for image vulnerability"""
        steps = []

        if vuln.get('FixedVersion'):
            steps.append(f"Update {vuln['PkgName']} to version {vuln['FixedVersion']}")
            steps.append("Rebuild Docker image with updated dependencies")

        steps.append("Scan image again to verify fix")

        return steps
